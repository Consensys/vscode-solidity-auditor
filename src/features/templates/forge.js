const generateForgeTemplate = (contract, generateForkStub) => {
  const contractTypeName = contract.name;
  const contractInstanceName = contractTypeName.toLowerCase();
  const contractPath = contract.path;
  const getTestContractName = (type) =>
    type == 'fork' ? `${contractTypeName}ForkTest` : `${contractTypeName}Test`;
  let content = `\
/** 
 * autogenerated by solidity-visual-auditor 
 * Run the tests with 'forge test -vvv' to see the console logs 
**/

// SPDX-License-Identifier: UNLICENSED
pragma solidity ${contract.pragma};

import {Test, console2} from "forge-std/Test.sol";
import ${contractTypeName} from "${contractPath}";

contract ${getTestContractName()} is Test {

    // https://book.getfoundry.sh/forge/writing-tests
     
    ${contractTypeName} public ${contractInstanceName};
    address immutable deployer = 0xaA96b71DA3E88aF887779056d0cc4A91C12BaAAA;
    address immutable firstOwnerAddress = 0xaA96B71da3e88AF887779056D0CC4A91c12bbBBb;
    address immutable secondOwnerAddress = 0xAA96b71DA3E88af887779056D0Cc4a91C12bCccc;
    address immutable externalAddress = 0xAA96b71Da3e88af887779056d0CC4A91C12BDDdd;

    //the setUp function is invoked before each test case
    function setUp() public {
        ${contractInstanceName} = new ${contractTypeName}();
    }

    //test: Functions prefixed with test are run as a test case. 
    function test_CallFromDeployer() public {
        ${contractInstanceName}.myFunction();
    }

    function test_CallFromExternalAddress() public {
        vm.prank(externalAddress);
        ${contractInstanceName}.myFunction();
    }

    // testFail: The inverse of the test prefix - if the function does not revert, the test fails
    function testFail_CallFromExternalAddress() public {
        vm.prank(externalAddress);
        ${contractInstanceName}.myFunction();
    }

    // https://book.getfoundry.sh/cheatcodes/expect-revert
    // A good practice is to use the pattern test_Revert[If|When]_Condition in combination with the expectRevert cheatcode 
    // Instead of using testFail, you know exactly what reverted and with which error
    function testRevertFromExternalAddress() public {
        vm.prank(firstOwnerAddress);
        ${contractInstanceName}.myPrivilegedFunction();
        vm.prank(externalAddress);
        vm.expectRevert("revertMsg");
        ${contractInstanceName}.myPrivilegedFunction();
    }

    // https://book.getfoundry.sh/forge/fuzz-testing
    function testFuzz_CallMyFunction(uint256 x) public {
        vm.prank(externalAddress);
        x = bound(x, 100, 1e36);
        bool res = ${contractInstanceName}.myFunction(x);
        assertEq(res, true);
    }
}`;

  if (generateForkStub) {
    content += `
contract ${getTestContractName('fork')} is Test {
    // the identifiers of the forks
    uint256 mainnetFork;
    uint256 optimismFork;

    //Load RPC URLs from .env file
    string MAINNET_RPC_URL = vm.envString("MAINNET_RPC_URL");
    string OPTIMISM_RPC_URL = vm.envString("OPTIMISM_RPC_URL");

    // create two _different_ forks during setup
    function setUp() public {
        mainnetFork = vm.createFork(MAINNET_RPC_URL);
        optimismFork = vm.createFork(OPTIMISM_RPC_URL);
    }

    // creates a new contract while a fork is active
    function testCreateContract() public {
        vm.selectFork(mainnetFork);
        assertEq(vm.activeFork(), mainnetFork);

        //create contract
        ${contractTypeName} ${contractInstanceName} = new ${contractTypeName}();

        // and can be used as normal
        ${contractInstanceName}.set(x);
        assertEq(${contractInstanceName}.value(), 100);
    }

     // creates a new _persistent_ contract while a fork is active
     function testCreatePersistentContract() public {
        vm.selectFork(mainnetFork);
        ${contractTypeName} ${contractInstanceName} = new ${contractTypeName}();

        // mark the contract as persistent so it is also available when other forks are active
        vm.makePersistent(address(${contractInstanceName}));
        assert(vm.isPersistent(address(${contractInstanceName})));

        vm.selectFork(optimismFork);
        assert(vm.isPersistent(address(${contractInstanceName})));

        // This will succeed because the contract is now also available on the 'optimismFork'
        assertEq(${contractInstanceName}.value(), 100);
     }
}
`;
  }
  return content;
};

module.exports = {
  generateForgeTemplate,
};
